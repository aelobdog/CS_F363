   program.node = mkNode(program, otherFunctions.node, mainFunction.node)
   mainFunction.node = stmts.node
   otherFunctions.node = mkNode(otherFunctions, function.node, otherFunctions1.node)
   function.name = TK_FUNID.value
   function.node = mkNode(function, input_par.node, output_par.node, stmts.node)
   input_par.node = parameter_list.node
   output_par.node = parameter_list.node
   id.node = mkLeaf(TK_ID, TK_ID.entry)
   addType(TK_ID.entry, dataType.type)
   parameter_list.node = mkNode(parameter_list, id.node, remaining_list.node)
   dataType.type = primitiveDatatype.type
   dataType.type = constructedDatatype.type
   primitiveDatatype.type = integer
   primitiveDatatype.type = real
   constructedDatatype.ctype = record
   constructedDatatype.name = TK_RUID.value
   constructedDatatype.ctype = record
   constructedDatatype.name = TK_RUID.value
   constructedDatatype.name = TK_RUID.value
   remaining_list.node = parameter_list.node
   stmts.node = mkNode(stmts, typeDefinitions.node, declarations.node, otherStmts.node, returnStmt.node)
   typeDefinitions.node = mkNode(typeDefinitions, actualOrRedefined.node, typeDefinitions.node)
   actualOrRedefined.node = typeDefinition.node
   actualOrRedefined.node = definetypestmt.node
   ruid.node = mkLeaf(TK_RUID, TK_RUID.value)
   ruid.name = TK_RUID.value
   ruid.ctype = record
   typeDefinition.node = mkNode(typeDefinition, ruid.node, fieldDefinitions.node)
   ruid.node = mkLeaf(TK_RUID, TK_RUID.value)
   ruid.name = TK_RUID.value
   ruid.ctype = union
   typeDefinition.node = mkNode(typeDefinition, ruid.node, fieldDefinitions.node)
   fieldDefinitions.node = mkNode(fieldDefinitions, fieldDefinition1.node, fieldDefinition2.node, moreFields.node)
   fid.node = mkLeaf(TK_FIELDID, TK_FIELDID.entry)
   addType(TK_FIELDID.entry, fieldtype.type)
   fieldDefinition.node = fid.node
   fieldtype.type = primitiveDatatype.type
   fieldtype.type = TK_RUID.name
   moreFields.node = mkNode(morefields, fieldDefinition.node, moreFields1.node)
   declarations.node = mkNode(declarations, declaration.node, declarations1.node)
   id.node = mkLeaf(TK_ID, TK_ID.entry)
   addType(TK_ID.entry, dataType.type)
   addGlobalStatus(TK_ID.entry, global_or_not.isGlobal)
   declaration.node = id.node
   global_or_not.isGlobal = true
   global_or_not.isGlobal = false
   otherStmts.node = mkNode(otherStmts, stmt.node, otherStmts1.node)
   stmt.node = assignmentStmt.node
   stmt.node = iterativeStmt.node
   stmt.node = conditionalStmt.node
   stmt.node = ioStmt.node
   stmt.node = funCallStmt.node
   assignmentStmt.node = mkNode(assignmentStmt, singleOrRecId.node, arithmeticExpression.node)
   id.node = mkLeaf(TK_ID, TK_ID.entry)
   singleOrRecId.node = mkNode(singleOrRecId, id.node, constructedVariable.node)
   constructedVariable.node = mkNode(constructedVariable, oneExpansion.node, moreExpansions.node)
   fid.node = mkLeaf(TK_FIELDID, TK_FIELDID.entry)
   oneExpansion.node = fid.node
   moreExpansions.node = mkNode(moreExpansions, oneExpansion.node, moreExpansions1.node)
   funid.node = mkLeaf(TK_FUNID, TK_FUNID.value)
   funCallStmt.node = mkNode(funCallStmt, outputParameters.node, funid.node, inputParameters.node)
   outputParameters.node = idList.node
   inputParameters.node = idList.node
   iterativeStmt.node = mkNode(iterativeStmt, booleanExpression.node, stmt.node, otherStmts.node)
   conditionalStmt.node = mkNode(conditionalStmt, booleanExpression.node, stmt.node, otherStmts.node, elsePart.node)
   elsePart.node = mkNode(elsePart, stmt.node, otherStmts.node)
   ioStmt.node = var.node
   ioStmt.iop = read
   ioStmt.node = var.node
   ioStmt.iop = write
   arithmeticExpression.node = mkNode(arithmeticExpression, term.node, expPrime.node)
   expPrime.node = mkNode(expPrime, lowPrecedenceOperators.node, term.node, expPrime.node)
   term.node = mkNode(term, factor.node, termPrime.node)
   termPrime.node = mkNode(termPrime, highPrecedenceOperator.node, factor.node, termPrime.node)
   factor.node = arithmeticExpression.node
   factor.node = var.node
   highPrecedenceOperator.op = MUL
   highPrecedenceOperator.op = DIV
   lowPrecedenceOperators.op = PLUS
   lowPrecedenceOperators.op = MINUS
   booleanExpression.op = logicalOp.op
   booleanExpression.node = mkNode(booleanExpression, booleanExpression1.node, booleanExpression2.node)
   booleanExpression.op = relationalOp.op
   booleanExpression.node = mkNode(booleanExpression, var1.node, var2.node)
   booleanExpression.op = NOT
   booleanExpression.node = mkNode(booleanExpression, booleanExpression1.node)
   var.node = singleOrRecId.node
   var.type = integer
   var.node = mkLeaf(NUM, num.value)
   var.type = real
   var.node = mkLeaf(RNUM,rnum.value)
   logicalOp.op = AND
   logicalOp.op = OR
   relationalOp.op = LT
   relationalOp.op = LE
   relationalOp.op = EQ
   relationalOp.op = GT   
   relationalOp.op = GE
   relationalOp.op = NE
   returnStmt.node = optionalReturn.node
   optionalReturn.node = idList.node
   id.node = mkLeaf(TK_ID, TK_ID.entry)
   idList.node = mkNode(idList, id.node, more_ids.node)
   more_ids.node = idList.node
   ruid1.node = mkLeaf(TK_RUID1, TK_RUID1.value)
   ruid2.node = mkLeaf(TK_RUID2, TK_RUID2.value)
   definetypestmt.node = mkNode(definetypestmt, ruid1.node, ruid2.node)   
   A.ctype = record
   A.ctype = union
